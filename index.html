<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GonchiTest</title>
<style>
  :root{
    --bg:#0b0f19; --card:#121829; --muted:#8aa0b4; --accent:#5fd3a1; --warn:#ffcc66; --text:#eef2f8;
    --border:#1e2a3f; --danger:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; background:var(--bg); color:var(--text);}
  header{padding:18px 20px; border-bottom:1px solid var(--border); background:linear-gradient(180deg,#0c1222,#0a0e18)}
  h1{font-size:20px;margin:0 0 6px 0}
  .sub{color:var(--muted); font-size:13px}
  main{display:grid; grid-template-columns: 1.25fr 1fr; gap:16px; padding:16px; align-items:start}
  .panel{background:var(--card); border:1px solid var(--border); border-radius:16px; padding:14px; box-shadow:0 8px 30px rgba(0,0,0,.25)}
  .panel h2{font-size:16px; margin:0 0 10px 0}
  textarea{width:100%; height:220px; background:#0a1020; color:var(--text); border:1px solid var(--border); border-radius:12px; padding:10px; font-size:14px; resize:vertical}
  label{font-size:13px; color:var(--muted)}
  input[type="number"], input[type="text"], input[type="password"], select{background:#0a1020; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:6px; font-size:14px}
  button{background:var(--accent); color:#0a1120; border:0; padding:10px 12px; border-radius:12px; font-weight:600; cursor:pointer}
  button.secondary{background:#1d2b45; color:var(--text);}
  button.warn{background:var(--warn); color:#111}
  .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
  .qcard{background:#0a1020; border:1px solid var(--border); border-radius:14px; padding:12px; margin:10px 0}
  .muted{color:var(--muted); font-size:12px}
  .pill{display:inline-block; padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:12px; color:var(--muted);}
  .choices{display:grid; gap:8px; margin-top:10px}
  .choice{padding:10px; border:1px solid var(--border); border-radius:10px; cursor:pointer; background:#0e152a}
  .choice.correct{border-color:#5fd3a1}
  .choice.wrong{border-color:var(--danger)}
  .flex{display:flex; justify-content:space-between; align-items:center}
  .tag{font-size:11px; color:#9fb2c7; border:1px solid var(--border); padding:2px 6px; border-radius:8px}
  .small{font-size:12px}
  .hint{background:#0e152a; border:1px dashed var(--border); border-radius:10px; padding:8px; margin-top:8px; color:#c8d4e3}
  .footer{padding:12px 16px; border-top:1px solid var(--border); display:flex; justify-content:space-between; align-items:center; gap:12px}
  .inline{display:inline-flex; gap:8px; align-items:center}
  .kbd{background:#11182b; border:1px solid var(--border); border-radius:6px; padding:2px 6px; font-size:12px}
  .danger{color:var(--danger)}
  @media (max-width: 980px){ main{grid-template-columns:1fr;}; }
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; color:#dbe8f5}
</style>
</head>
<body>
<header>
  <h1>GonchiTest</h1>
  <div class="sub">Crea test a partir de los temas en pdf conectandose a una IA</div>
</header>

<main>
  <section class="panel">
    <h2>1) Selecciona temas (desde tu repositorio via Cloudflare)</h2>
  
    <div class="grid2">
      <div>
        <label>URL del Worker (se guarda localmente)</label>
        <input type="text" id="workerBase" placeholder="https://TU-WORKER.workers.dev">
      </div>
      <div>
        <label>Filtro r√°pido</label>
        <input type="text" id="temaFilter" placeholder="Filtrar por nombre...">
      </div>
    </div>
  
    <div class="row" style="margin-top:8px">
      <button class="secondary" id="btnRefrescarTemas">Refrescar</button>
      <button class="secondary warn" id="btnVaciarSeleccion">Vaciar selecci√≥n</button>
      <span id="selCount" class="pill">Seleccionados: 0</span>
      <span id="temasStatus" class="pill">Cargando‚Ä¶</span>
    </div>

    <div class="row" style="margin-top:6px; flex-wrap:wrap; gap:6px" id="groupControls"></div>
  
    <div id="temasArea" style="max-height:260px; overflow:auto; margin-top:8px; border:1px solid var(--border); border-radius:10px; padding:8px"></div>
  
    <div class="row" style="margin-top:10px">
      <label>M√°x. preguntas a generar:</label>
      <input type="number" id="maxQs" min="5" max="200" value="30">
      <button id="generateAI">Generar con IA (API)</button>
      <span class="muted">‚ö†Ô∏è Usa el proxy del Worker si no quieres exponer tu key en el cliente.</span>
    </div>
  
    <div class="hint" style="margin-top:10px">
      <b>C√≥mo funciona</b>: esta lista la trae <code>/temas</code> de tu Worker. Marca 1 o varios temas y pulsa ‚ÄúGenerar con IA‚Äù.
    </div>
  </section>  

  <section class="panel">
  <h2>2) Configuraci√≥n</h2>
  <div class="grid2">
    <div>
      <label>Dificultad</label>
      <select id="difficulty">
        <option value="auto">Auto (equilibrado)</option>
        <option value="easy">F√°cil</option>
        <option value="medium">Media</option>
        <option value="hard">Dif√≠cil</option>
      </select>
    </div>

    <div>
      <label>Reparto por temas</label>
      <select id="distMode">
        <option value="equal">Equitativo (mismo n¬∫ por tema)</option>
        <option value="prop">Proporcional (seg√∫n longitud)</option>
      </select>
    </div>

    <div>
      <label>Formato exportaci√≥n</label>
      <select id="exportFmt">
        <option value="csv">CSV (Excel)</option>
        <option value="anki">Anki (CSV front;back)</option>
        <option value="remnote">RemNote (Markdown)</option>
      </select>
    </div>
  </div>

  <div class="row" style="margin-top:12px">
    <button id="startQuiz">Empezar Quiz</button>
    <button class="secondary" id="reviewWrong">Revisar fallos</button>
    <button class="secondary" id="exportDeck">Exportar</button>
  </div>
  <div class="muted" style="margin-top:8px">Tip: genera por ep√≠grafe ‚Üí exporta ‚Üí repasa con espaciado.</div>
</section>

  <section class="panel" style="grid-column:1 / -1">
    <div class="flex">
      <h2>3) Ejercicio</h2>
      <div class="inline">
        <span id="progress" class="pill">0/0</span>
        <span id="score" class="pill">Puntuaci√≥n: 0</span>
        <span id="due" class="pill">Pendientes hoy: 0</span>
        <span id="status" class="pill">Listo</span>
      </div>
    </div>
    <div id="quizArea"></div>
    <div class="footer">
      <div class="inline">
        <span class="small muted">Atajos: <span class="kbd">1‚Äì5</span> responde | <span class="kbd">N</span> siguiente</span>
      </div>
      <div class="inline">
        <button class="secondary" id="prevQ">‚üµ Anterior</button>
        <button id="nextQ">Siguiente ‚ü∂</button>
      </div>
    </div>

    <details class="hint" style="margin-top:10px">
      <summary>Formato JSON esperado de la IA</summary>
      <pre><code>{
  "questions":[
    {"type":"mcq","question":"...","choices":["A","B","C","D"],"answer":"C","explanation":"...","source_quote":"..."},
  ]
}</code></pre>
    </details>
  </section>
</main>

<script>
/* ---------- Utilidades ---------- */
const stopwords = new Set(`a,al,algo,algunas,algunos,ante,antes,como,con,contra,cuando,De,de,del,desde,donde,durante,e,el,ella,ellas,ellos,em,bajo,hasta,la,las,lo,los,mas,m√°s,me,mi,m√≠,mientras,mis,mi,mis,modo,muy,ni,no,nos,nuestro,nosotros,o,os,otra,otros,para,pero,por,porque,que,qu√©,quien,qui√©n,se,sin,sobre,su,sus,te,tu,t√∫,tus,un,una,uno,unos,unas,ya,si,s√≠,ser,son,es,esta,este,esto,estas,estos,ha,han,hay,fue,eran,ser√°,ser√°n,tambi√©n,entre,mediante,seg√∫n,cada,debido`.split(',').map(s=>s.trim()));
function seedRandom(seed){ let s = seed % 2147483647; if (s<=0) s+=2147483646; return ()=> (s = s*16807 % 2147483647)/2147483647; }
function shuffle(arr, rnd=Math.random){ for(let i=arr.length-1;i>0;i--){ const j = Math.floor(rnd()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr;}
function tokenize(s){
  return s.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu,' ').split(/\s+/).filter(w=>w && !stopwords.has(w) && w.length>2 && !/^\d+$/.test(w));
}
function topTerms(text, k=50){
  const freq = new Map(); const words = tokenize(text);
  for(const w of words){ freq.set(w,(freq.get(w)||0)+1); }
  const entries = [...freq.entries()].sort((a,b)=>b[1]-a[1]);
  return entries.slice(0,k).map(([w,c])=>w);
}
function sentenceScore(sent, keyset){
  const toks = tokenize(sent); let c=0; for(const t of toks){ if(keyset.has(t)) c++; } return c + Math.min(2, Math.floor(sent.length/120));
}
function pickN(arr, n, rnd=Math.random){ arr = arr.slice(); shuffle(arr, rnd); return arr.slice(0,n); }
function todayISO(){ return new Date().toISOString().slice(0,10); }
function setStatus(msg){ document.getElementById('status').textContent = msg; }

function normTxt(s){
  return String(s||'')
    .replace(/^[‚Äú"'\s]+|[‚Äù"'\s]+$/g,'')
    .replace(/\s+/g,' ')
    .replace(/[.;,:]\s*$/,'')
    .trim()
    .toLowerCase();
}

// Baraja choices y remapea √≠ndices de correcta/seleccionada
function shuffleChoicesAndMap(choices, correctIdx, selectedIdx=null){
  if (!Array.isArray(choices)) return { choices: [], correctIdx: -1, selectedIdx: -1 };
  const idxs = choices.map((_,i)=>i);
  for(let i=idxs.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [idxs[i], idxs[j]] = [idxs[j], idxs[i]];
  }
  const newChoices = idxs.map(i => choices[i]);
  const newCorrectIdx  = idxs.indexOf(correctIdx);
  const newSelectedIdx = (selectedIdx!=null && selectedIdx>=0) ? idxs.indexOf(selectedIdx) : null;
  return { choices: newChoices, correctIdx: newCorrectIdx, selectedIdx: newSelectedIdx };
}


function deduceCorrectIndex(q){
  const choices = (q.choices||[]).map(c=>String(c));
  // 1) Si viene answer_index v√°lido
  if (Number.isInteger(q.answer_index) && q.answer_index>=0 && q.answer_index<choices.length){
    return q.answer_index;
  }
  // 2) Si answer es letra A-D
  if (typeof q.answer === 'string'){
    const a = q.answer.trim();
    const mL = a.match(/^[A-D]\s*(?:[).:\-]\s*)?$/i);
    if (mL){ return {A:0,B:1,C:2,D:3}[mL[0][0].toUpperCase()] ?? -1; }
    // 3) Si answer es n√∫mero 1-4 SOLO si es √≠ndice puro
    const mN = a.match(/^[1-4]\s*(?:[).:\-]\s*)?$/);
    if (mN){ return parseInt(mN[0],10)-1; }
    // 4) Igual por texto (normalizado)
    const idxEq = choices.findIndex(c => normTxt(c) === normTxt(a));
    if (idxEq !== -1) return idxEq;
  }
  // 5) Si hay source_quote, intentar mapear por fuente
  if (q.source_quote){
    const idxSrc = choices.findIndex(c => normTxt(c) === normTxt(q.source_quote));
    if (idxSrc !== -1) return idxSrc;
  }
  return -1; // fallback
}

/* ---------- Estado ---------- */
let QUESTIONS = [];
let CURRENT = 0;
let SCORE = 0;
let CORRECT = 0;
let INCORRECT = 0;
let RNG = Math.random;
let WRONG = new Set();
let SRS = {}; // id -> {interval, due}
const DFLT_INTERVALS = [1,3,7,14,30];

function saveState(){
  localStorage.setItem('quiz_wrong', JSON.stringify([...WRONG]));
  localStorage.setItem('quiz_srs', JSON.stringify(SRS));
  
}
function loadState(){
  const s = localStorage.getItem('quiz_srs'); if(s){ SRS = JSON.parse(s); }
  const w = localStorage.getItem('quiz_wrong');
    if (w) { try { WRONG = new Set(JSON.parse(w)); } catch(e){} }

  updateDueBadge();
}

// ====== Selecci√≥n de temas v√≠a Cloudflare ======
let TEMAS = [];                // [{key, name, group}]
let SELECCION = new Set();     // keys seleccionadas (p.ej. "GrupoII/GII T01 ....pdf")

function getWorkerBase(){
  let base = (document.getElementById('workerBase')?.value || '').trim();
  if (base.endsWith('/')) base = base.slice(0,-1);
  return base;
}

function setTemasStatus(msg){ const el = document.getElementById('temasStatus'); if(el) el.textContent = msg; }
function updateSelCount(){ const el = document.getElementById('selCount'); if(el) el.textContent = `Seleccionados: ${SELECCION.size}`; }

// ---- Utilidades fetch con reintentos y cach√© ----
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function fetchJSONWithRetry(url, {retries=3, baseDelay=400} = {}){
  let attempt = 0;
  let lastErr = null;
  while (attempt <= retries){
    try{
      const res = await fetch(url, { method:'GET', cache:'no-store' });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    }catch(e){
      lastErr = e;
      if (attempt === retries) break;
      const jitter = Math.random()*120;
      await sleep(baseDelay * Math.pow(2, attempt) + jitter); // 0.4s, 0.8s, 1.6s...
      attempt++;
    }
  }
  throw lastErr || new Error('Network error');
}

function saveTemasCache(base, items){
  try{ localStorage.setItem('temas_cache_'+base, JSON.stringify({ts:Date.now(), items})); }catch{}
}

function loadTemasCache(base){
  try{
    const raw = localStorage.getItem('temas_cache_'+base);
    if(!raw) return null;
    const obj = JSON.parse(raw);
    return obj?.items || null;
  }catch{ return null; }
}

async function listarTemas(auto=false){
  const base = getWorkerBase();
  if(!base){
    setTemasStatus('Falta URL del Worker');
    if(!auto) alert('Indica la URL del Worker (se guarda localmente).');
    return;
  }

  // 1) Pinta inmediatamente lo √∫ltimo cacheado (si existe)
  const cached = loadTemasCache(base);
  if (cached && cached.length){
    TEMAS = cached;
    renderTemas();
    setTemasStatus(`(cach√©) Temas: ${TEMAS.length}`);
  } else {
    setTemasStatus('Cargando‚Ä¶');
  }

  // 2) Lanza la carga ‚Äúreal‚Äù con reintentos
  try{
    const data = await fetchJSONWithRetry(base + '/temas', {retries: 3, baseDelay: 350});
    const items = Array.isArray(data.items) ? data.items : [];
    TEMAS = items;
    renderTemas();
    setTemasStatus(`Temas: ${TEMAS.length}`);
    saveTemasCache(base, items);
    try{ localStorage.setItem('worker_base', base); }catch{}
  }catch(e){
    console.warn('Fallo cargando /temas:', e);
    if (cached && cached.length){
      setTemasStatus(`Usando cach√© (${cached.length})`);
      // no alert si tenemos algo que mostrar
    } else {
      setTemasStatus('Error al cargar');
      if(!auto) alert('No se pudieron listar temas (intenta de nuevo).');
    }
  }
}


function renderTemas(){
  const wrap = document.getElementById('temasArea');
  const filtro = (document.getElementById('temaFilter')?.value || '').toLowerCase();
  wrap.innerHTML = '';

  if(!TEMAS.length){
    wrap.innerHTML = '<div class="muted small">No hay temas (¬øcarpetas GrupoII/GrupoIV vac√≠as?).</div>';
    return;
  }

  const list = document.createElement('div');
  for(const it of TEMAS){
    const label = `${it.group} ‚Ä¢ ${it.name}`;
    if (filtro && !label.toLowerCase().includes(filtro)) continue;

    const row = document.createElement('div');
    row.className = 'row';
    row.style.margin = '4px 0';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = SELECCION.has(it.key);
    cb.addEventListener('change', ()=>{
      if(cb.checked) SELECCION.add(it.key);
      else SELECCION.delete(it.key);
      updateSelCount();
    });

    const sp = document.createElement('span');
    sp.textContent = label;
    sp.className = 'small';

    row.appendChild(cb);
    row.appendChild(sp);
    list.appendChild(row);
  }

  wrap.appendChild(list);
  updateSelCount();
  renderGroupControls();
}

// Seleccionar Temas de un grupo, o seleccionar todos
function getGroups(){
  const map = new Map(); // group -> array de items
  for(const it of TEMAS){
    if(!map.has(it.group)) map.set(it.group, []);
    map.get(it.group).push(it);
  }
  return map;
}

function selectGroup(group, checked=true){
  for(const it of TEMAS){
    if(it.group === group){
      if(checked) SELECCION.add(it.key);
      else SELECCION.delete(it.key);
    }
  }
  updateSelCount();
  renderTemas();
  renderGroupControls(); // refresca contadores
}

function selectAllInList(){
  for(const it of TEMAS){ SELECCION.add(it.key); }
  updateSelCount();
  renderTemas();
  renderGroupControls();
}

function clearAllSelection(){
  SELECCION.clear();
  updateSelCount();
  renderTemas();
  renderGroupControls();
}

function renderGroupControls(){
  const wrap = document.getElementById('groupControls');
  if(!wrap) return;
  const groups = getGroups();

  // Botones globales
  let html = `
    <button class="secondary" onclick="selectAllInList()">Seleccionar todo</button>
    <button class="secondary warn" onclick="clearAllSelection()">Quitar todo</button>
  `;

  // Botones por grupo
  for(const [g, items] of groups.entries()){
    const selected = items.filter(it => SELECCION.has(it.key)).length;
    const allSel = selected === items.length && items.length>0;

    html += `
      <span class="pill" style="margin-left:8px">${g}: ${selected}/${items.length}</span>
      <button class="secondary" style="padding:6px 8px" onclick="selectGroup('${g.replace(/'/g,"\\'")}', true)">
        Seleccionar ${g}
      </button>
      <button class="secondary" style="padding:6px 8px" onclick="selectGroup('${g.replace(/'/g,"\\'")}', false)">
        Quitar ${g}
      </button>
    `;
  }
  wrap.innerHTML = html;
}


// Descarga texto plano del tema (usa /texto del Worker)
async function fetchTextoTema(key){
  const base = getWorkerBase();
  if(!base) throw new Error('Falta URL del Worker');
  const url = `${base}/texto?key=${encodeURIComponent(key)}`;
  const res = await fetch(url, { method:'GET' });
  if(!res.ok){
    throw new Error(`HTTP ${res.status} al obtener ${key}. Aseg√∫rate de que existe Texto/${key.replace(/\.pdf$/i,'.txt')} en GitHub.`);
  }
  return res.text();
}

// Inicializa: carga workerBase guardado, auto-lista, y listeners
function initTemasUI(){
  try{
    const saved = localStorage.getItem('worker_base');
    if(saved && document.getElementById('workerBase')){
      document.getElementById('workerBase').value = saved;
    }
  }catch{}

  // Auto listar en carga (si hay URL guardada)
  listarTemas(true);

  // Listeners
  const filtro = document.getElementById('temaFilter');
  if (filtro) filtro.addEventListener('input', renderTemas);

  const refrescar = document.getElementById('btnRefrescarTemas');
  if (refrescar) refrescar.addEventListener('click', ()=> listarTemas(false));

  const vaciar = document.getElementById('btnVaciarSeleccion');
  if (vaciar) vaciar.addEventListener('click', ()=>{ SELECCION.clear(); renderTemas(); });
}

document.addEventListener('DOMContentLoaded', initTemasUI);

/* ---------- Generaci√≥n con IA ---------- */
async function generateAI(){
  if (SELECCION.size === 0) { alert("Selecciona al menos un tema."); return; }
  const workerBase = getWorkerBase();
  if (!workerBase){ alert("Indica la URL del Worker arriba."); return; }
  const endpoint  = workerBase;
  const maxQs     = parseInt(document.getElementById('maxQs').value,10)||30;
  const perCall   = 12;
  const difficulty = document.getElementById('difficulty').value;
  const distMode   = (document.getElementById('distMode')?.value) || 'equal';

  setStatus('IA: preparando‚Ä¶');

  const keys = [...SELECCION];

  // 1) Descarga texto de CADA tema (por separado)
  const textosByKey = {};
  try{
    const textos = await Promise.all(
      keys.map(k => fetchTextoTema(k).catch(e => `[ERROR ${k}]: ${e.message}`))
    );
    keys.forEach((k, i) => textosByKey[k] = (textos[i]||'').trim());
  }catch(e){
    console.error(e);
    alert('Error descargando textos: ' + e.message);
    return;
  }

  // 2) Calcula cupos por tema
  let quotas;
  if (distMode === 'prop'){
    // Igual que antes
    const weights = keys.map(k => Math.max(1, textLen(textosByKey[k])));
    quotas = allocateCounts(maxQs, weights);
  } else {
    // === Reparto equitativo con resto aleatorio ===
    const n = keys.length;
    const base = Math.floor(maxQs / n);
    let rem = maxQs - base * n;
    quotas = Array(n).fill(base);

    // Elige 'rem' √≠ndices al azar y suma +1 a esos temas
    const idxs = [...keys.keys()];
    shuffle(idxs, RNG); // ya tienes shuffle() y RNG definidos
    for (let i = 0; i < rem; i++) quotas[idxs[i]] += 1;
  }

  // 3) Genera por tema, respetando cupo y repartiendo por chunk
  const out = [];
  for (let t = 0; t < keys.length; t++) {
    const key = keys[t];
    const needForThisTopic = quotas[t];
    if (needForThisTopic <= 0) continue;

    const baseText = textosByKey[key] || '';
    if (!baseText) continue;

    // ===== Tema completo como √∫nico "chunk" =====
    const whole = baseText;
    let made = 0;
    const seenStems = new Set(); // deduplicaci√≥n de enunciados

    while (made < needForThisTopic && out.length < maxQs) {
      const batch = Math.min(perCall, needForThisTopic - made);
      setStatus(`IA: ¬´${key}¬ª ‚Äì tema completo (${made}/${needForThisTopic})‚Ä¶`);
      try {
        const qs = await callChatJSON(endpoint, null, null, buildPrompt(whole, batch, ['mcq'], difficulty));
        for (const q of qs) {
          if (q.type !== 'mcq' || !q.choices) continue;
          const stemTxt = (q.stem || q.question || '').trim();
          const normStemTxt = normTxt(stemTxt);
          if (seenStems.has(normStemTxt)) continue; // evita duplicados entre tandas
          seenStems.add(normStemTxt);
          
          const shortName = key.split('/').pop().replace(/\.pdf$/i, '');

          const id = 'ai_' + (out.length + 1);
          const correctIdx = deduceCorrectIndex(q);
          out.push({
            id,
            type: 'mcq',
            topic: key, // Tema de origen ‚Üí bien para filtrar o analizar despu√©s
            stem: q.question, // Enunciado
            sent: `[${shortName}] ${q.source_quote || ''}`, // Fuente (si existe)
            answer: q.answer, // Texto de la respuesta (por compatibilidad/exportar)
            choices: q.choices, // Opciones A‚ÄìD
            explanation: q.explanation || '', // Explicaci√≥n opcional
            answer_index: q.answer_index, // √çndice correcto (si lo devolvi√≥ la IA)
            correctIdx, // √çndice deducido por funci√≥n
          });
          made++;
          if (made >= needForThisTopic) break;
        }
      } catch (e) {
        console.error(e);
        break; // pasa al siguiente tema si esta llamada fall√≥
      }
    }
    if (out.length >= maxQs) break;
  }
  
  if(out.length===0){ setStatus('IA: sin resultados'); return; }

  // 4) Mezcla las preguntas para no agrupar por tema y resetea estado
  shuffle(out);
  QUESTIONS = out;
  CURRENT = 0; SCORE = 0; WRONG.clear();
  CORRECT = 0; INCORRECT = 0;
  const next = document.getElementById('nextQ'); if(next) next.disabled = false;

  updateUI();
  saveState();
  setStatus('IA: listo');
}

function buildPrompt(text, n, _types, difficulty){
  const mapDiff = {easy:'b√°sico', medium:'medio', hard:'dif√≠cil', auto:'equilibrado'};
  return [
    { role:"system", content:
      "Eres un generador de preguntas tipo test (opci√≥n m√∫ltiple) para una oposici√≥n espa√±ola de ingenier√≠a industrial. Devuelve JSON ESTRICTO y coherente con el esquema."
    },
    { role:"user", content:
`Texto base:
"""${text}"""

Genera EXACTAMENTE ${n} preguntas MCQ de dificultad ${mapDiff[difficulty]||'equilibrado'}.

Reglas:
- 4 opciones (A‚ÄìD) en "choices". 1 correcta y 3 distractores pausibles y no triviales.
- Distribuye las preguntas a lo largo de TODO el tema dado, no solo del inicio.
- Devuelve SIEMPRE "answer_index" (0,1,2,3) se√±alando la opci√≥n correcta.
- Adem√°s incluye "answer" con el TEXTO correcto (coincidiendo con choices[answer_index]).
- Incluye "explanation" y "source_quote" (‚â§100 palabras) del texto.

Devuelve SOLO JSON con este esquema exacto:
{
  "questions":[
    {
      "type":"mcq",
      "question":"...",
      "choices":["Opci√≥n A","Opci√≥n B","Opci√≥n C","Opci√≥n D"],
      "answer_index": 2,
      "answer":"Texto exacto de choices[2]",
      "explanation":"...",
      "source_quote":"..."
    }
  ]
}` }
  ];
}

function textLen(s){ return (s || '').length; }

// Asignaci√≥n por ‚Äúmayores restos‚Äù para que la suma d√© exactamente 'total'
function allocateCounts(total, weights){
  // weights: array de n√∫meros >=0 (uno por tema)
  const sum = weights.reduce((a,b)=>a+b, 0) || 1;
  const raw = weights.map(w => (w / sum) * total);
  const floor = raw.map(x => Math.floor(x));
  let used = floor.reduce((a,b)=>a+b, 0);
  const rems = raw.map((x,i)=> ({i, frac: x - floor[i]}));
  // Baraja para romper empates de forma aleatoria
  shuffle(rems, RNG);
  rems.sort((a,b)=> b.frac - a.frac);
  // reparte los que faltan a los de mayor resto
  for(let k=0; used < total && k < rems.length; k++, used++){
    floor[rems[k].i] += 1;
  }
  return floor; // array con cupos por tema
}

async function callChatJSON(endpoint, _apiKey, model, messages){
  // El Worker ignora "model"; recibe {messages} y devuelve estilo OpenAI
  const body = {
    model: model || "gemini-2.5-flash",
    messages,
    temperature: 0.2,
    response_format: {"type":"json_object"}
  };
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  const raw = await res.text().catch(()=> '');
  if(!res.ok){
    throw new Error(`HTTP ${res.status}: ${raw.slice(0,500)}`);
  }
  // OpenAI-style or Gemini raw text
  let content = null;
  try {
    const data = JSON.parse(raw);
    if (data?.choices?.[0]?.message?.parsed?.questions) {
      return data.choices[0].message.parsed.questions;
    }
    content = data?.choices?.[0]?.message?.content ?? data?.output_text ?? raw;
  } catch {
    content = raw || '';
  }
  // intenta JSON directo
  try {
    const obj = JSON.parse(content);
    if (Array.isArray(obj.questions)) return obj.questions;
  } catch {}
  // intenta extraer el primer bloque {...}
  const match = content.match(/\{[\s\S]*\}/);
  if (match) {
    try {
      const obj = JSON.parse(match[0]);
      if (Array.isArray(obj.questions)) return obj.questions;
    } catch {}
  }
  throw new Error('La IA no devolvi√≥ JSON v√°lido. Vista previa: ' + String(content).slice(0,500));
}

/* ---------- UI Quiz ---------- */
function updateUI(){
  document.getElementById('progress').textContent = `${QUESTIONS.length?CURRENT+1:0}/${QUESTIONS.length}`;
  document.getElementById('score').textContent = `Puntuaci√≥n: ${SCORE}`;
  renderCurrent();
  updateDueBadge();
  updateNavButtons();
}

function renderCurrent(){
  const area = document.getElementById('quizArea');
  area.innerHTML = '';
  if(QUESTIONS.length===0){
    area.innerHTML = '<div class="muted">Genera preguntas para empezar.</div>'; return;
  }
  const q = QUESTIONS[CURRENT];
  const card = document.createElement('div'); card.className='qcard';
  const header = document.createElement('div'); header.className='flex';
  header.innerHTML = `<div><span class="tag">MCQ</span></div><div class="muted small">√çtem ${CURRENT+1}</div>`;
  const stem = document.createElement('div'); stem.style.marginTop='8px'; stem.textContent = q.stem || q.question || '';
  card.appendChild(header); card.appendChild(stem);

  // Solo MCQ
  const div = document.createElement('div'); div.className='choices';
  q.choices.forEach((c,idx)=>{
    const btn = document.createElement('div'); btn.className='choice'; btn.textContent = (idx+1)+') '+c;
    btn.addEventListener('click', ()=>answerMCQ(btn, c, idx, q));
    div.appendChild(btn);
  });
  card.appendChild(div);

  // üëá Reaplicar resaltado si ya estaba respondida
  if (q.answered){
    const btns = [...div.children];
    // evita nuevos clics
    btns.forEach(el => el.style.pointerEvents = 'none');

    // deducir correcta
    let goldIdx = Number.isInteger(q.correctIdx) ? q.correctIdx : -1;
    if (goldIdx === -1) goldIdx = deduceCorrectIndex(q);

    // pinta correcta en verde
    if (goldIdx >= 0 && goldIdx < btns.length){
      btns[goldIdx].classList.add('correct');
      btns[goldIdx].classList.remove('wrong');
    }

    // si fall√≥, pinta su elecci√≥n en rojo
    if (Number.isInteger(q.selectedIdx) && q.selectedIdx !== goldIdx && q.selectedIdx >= 0 && q.selectedIdx < btns.length){
      btns[q.selectedIdx].classList.add('wrong');
      btns[q.selectedIdx].classList.remove('correct');
    }
  }

  if(q.explanation){
    const exp = document.createElement('div'); exp.className='muted small'; exp.style.marginTop='8px';
    exp.textContent = 'Explicaci√≥n: ' + q.explanation;
    card.appendChild(exp);
  }
  if(q.sent){
    const src = document.createElement('div'); src.className='muted small'; src.style.marginTop='4px';
    src.textContent = 'Fuente: ' + q.sent;
    card.appendChild(src);
  }

  area.appendChild(card);
}

function updateNavButtons(){
  const prev = document.getElementById('prevQ');
  const next = document.getElementById('nextQ');
  const n = QUESTIONS.length;
  if (!prev || !next) return;
  prev.disabled = (n === 0 || CURRENT === 0);
  if (n === 0) {
   next.disabled = true;
   next.textContent = 'Siguiente ‚ü∂';
   return;
 }
 if (CURRENT < n - 1) {
   next.disabled = false;
   next.textContent = 'Siguiente ‚ü∂';
 } else {
   // √öltima pregunta: bot√≥n activo como "Finalizar"
   next.disabled = false;
   next.textContent = 'Finalizar ‚úì';
 }
}


// Convierte "A/B/C/D" o "1/2/3/4" al texto real de la opci√≥n.
// Si ya es texto, lo deja igual.
function getCorrectText(q){
  const choices = (q.choices||[]).map(c => String(c).trim());
  let a = String(q.answer||'').trim();

  // Limpieza de texto de respuesta
  a = a
    .replace(/^respuesta\s*[:\-]\s*/i,'')
    .replace(/^correcta\s*[:\-]\s*/i,'')
    .replace(/^opci[o√≥]n\s*/i,'')
    .replace(/^[‚Äú‚Äù"'\(\[]\s*/,'')
    .replace(/\s*[‚Äù"'\)\]]$/,'')
    .replace(/^[-‚Äì‚Äî]\s*/,'')
    .trim();

  // Si parece una fecha o n√∫mero con texto detr√°s (ej. "4 de enero de 1977"),
  // NO lo trates como √≠ndice
  if (/^\d+\s+\p{L}/u.test(a)) {
    const found = choices.find(c => c.toLowerCase() === a.toLowerCase());
    if (found) return found;
  }

  // Letras A‚ÄìD ‚Üí √≠ndice 0‚Äì3
  const letter = a.match(/^[A-D](?=[).:\s]|$)/i);
  if(letter){
    const idx = {A:0,B:1,C:2,D:3}[letter[0].toUpperCase()];
    return choices[idx] ?? a;
  }

  // N√∫meros 1‚Äì4 SOLO si la cadena es solo el √≠ndice (sin texto detr√°s)
  const onlyIndex = a.match(/^[1-4]\s*(?:[).:\-]\s*)?$/);
  if (onlyIndex) {
    const idx = parseInt(onlyIndex[0], 10) - 1;
    return choices[idx] ?? a;
  }

  // "B) Texto correcto" ‚Üí "Texto correcto"
  const afterLetter = a.replace(/^[A-D][).:\-\s]+/i,'').trim();
  if (choices.includes(afterLetter)) return afterLetter;

  // Igualdad exacta por texto
  const found = choices.find(c => c.toLowerCase() === a.toLowerCase());
  return found || a;
}

function answerMCQ(btn, choice, idx, q){
  if (q.answered) return; // evita doble clic
  q.answered = true;
  q.selectedIdx = idx; // üëà guarda lo que eligi√≥ el usuario

  const btns = [...btn.parentElement.children];

  // Deducir √≠ndice correcto
  let goldIdx = Number.isInteger(q.correctIdx) ? q.correctIdx : -1;
  if (goldIdx === -1) { goldIdx = deduceCorrectIndex(q); q.correctIdx = goldIdx; }

  // Desactiva clicks en todas las opciones
  btns.forEach(el => el.style.pointerEvents = 'none');

  if (goldIdx >= 0 && goldIdx < (q.choices||[]).length){
    const correctBtn = btns[goldIdx];

    if (idx === goldIdx){
      // ‚úÖ Acierto: solo marcar la correcta en verde
      if (correctBtn){
        correctBtn.classList.add('correct');
        correctBtn.classList.remove('wrong'); // por si acaso
      }
      SCORE = (typeof SCORE === 'number' ? SCORE : 0) + 1;  // ‚úÖ Respuesta correcta ‚Üí +1
      CORRECT += 1;
      WRONG.delete(q.id);
      promoteSRS(q.id);
      // Si esta pregunta ven√≠a del repositorio de fallos (o est√° marcada como fallo local), la borramos del remoto
      (async () => {
        try{
          const base = getWorkerBase();
          if(!base) return;
          // Solo limpiar si realmente era un fallo previamente (de remoto o local)
          const wasWrong = q.fromWrong || WRONG.has(q.id);
          if(!wasWrong) return;
          const r = await fetch(base + '/clear-wrong', {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body: JSON.stringify({ ids:[q.id] })
          });
          if (!r.ok) {
            const txt = await r.text().catch(()=> '');
            console.warn('clear-wrong FAIL', r.status, txt);
          }
        }catch(e){
          console.warn('clear-wrong exception', e);
        }
      })();

    } else {
      // ‚ùå Fallo: mi elecci√≥n en rojo + correcta en verde
      const selectedBtn = btns[idx];
      if (selectedBtn) {
        selectedBtn.classList.add('wrong');
        selectedBtn.classList.remove('correct');
      }
      if (correctBtn){
        correctBtn.classList.add('correct');
        correctBtn.classList.remove('wrong');
      }
      SCORE = (typeof SCORE === 'number' ? SCORE : 0) - 1/3; // ‚ùå Respuesta incorrecta ‚Üí ‚àí1/3
      INCORRECT += 1;
      WRONG.add(q.id);
      resetSRS(q.id);
      // Enviar fallo al Worker (silencioso si falla)
      (async () => {
        try{
          const base = getWorkerBase();
          if(!base) return;

          const origCorrect = (Number.isInteger(q.correctIdx) ? q.correctIdx : deduceCorrectIndex(q));
          // üëá Barajar una vez al guardar 
          const { choices, correctIdx, selectedIdx } =
            shuffleChoicesAndMap(q.choices || [], origCorrect, idx);

          const payload = {
            id: q.id,
            topic: q.topic,
            stem: q.stem || q.question || '',
            choices,                 // ‚úÖ ya barajadas
            correctIdx,              // ‚úÖ remapeado
            selectedIdx,             // ‚úÖ remapeado
            explanation: q.explanation || '',
            source_quote: q.sent || q.source_quote || '',
            shuffled: true           // bandera informativa (opcional)
          };

          const r = await fetch(base + '/log-wrong', {
            method:'POST',
            headers:{ 'Content-Type':'application/json' },
            body: JSON.stringify(payload)
          });
          if(!r.ok){ console.warn('log-wrong FAIL', r.status, await r.text()); }
        }catch(e){ console.warn('log-wrong exception', e); }
      })();
    }

  } else {
    // Fallback si no podemos deducir la correcta: marca solo lo elegido en rojo
    const selectedBtn = btns[idx];
    if (selectedBtn) selectedBtn.classList.add('wrong');
    SCORE = (typeof SCORE === 'number' ? SCORE : 0) - 1/3;
    INCORRECT += 1;
    WRONG.add(q.id);
    resetSRS(q.id);
    console.warn('No se pudo deducir la opci√≥n correcta para esta pregunta.');
  }

  // Actualiza UI y guarda
  const scoreEl = document.getElementById('score');
  if (scoreEl) scoreEl.textContent = `Puntuaci√≥n: ${SCORE.toFixed(2)}`;
  saveState();
}


function normalize(s){ return (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim(); }

function nextQ(){
  if(QUESTIONS.length===0) return;

  if (CURRENT >= QUESTIONS.length - 1){
    // Ya est√°s en la √∫ltima ‚Üí muestra resultados y no sigas
    showResults();
    return;
  }

  CURRENT = Math.min(QUESTIONS.length-1, CURRENT+1);
  updateUI();
  saveState();
}

function prevQ(){
  if (CURRENT > 0){ CURRENT -= 1; updateUI(); saveState(); }
}

function showResults(){
  const total = QUESTIONS.length;
  const net = SCORE; // ya incluye +1 / -1/3
  const sobre10 = Math.max(0, (net / total) * 10); // nota en 0‚Äì10 (sin negativos)

  alert(
    `üèÅ Fin de la bater√≠a\n\n` +
    `‚úîÔ∏è Aciertos: ${CORRECT}\n` +
    `‚ùå Fallos:   ${INCORRECT}\n` +
    `üìä Puntuaci√≥n neta: ${net.toFixed(2)} / ${total}\n` +
    `üìù Nota (0‚Äì10): ${sobre10.toFixed(2)}`
  );

  // (Opcional) Ofrece pasar directamente a "Revisar fallos"
  // document.getElementById('reviewWrong').click();
}

/* ---------- SRS sencillo ---------- */
function promoteSRS(id){
  const now = todayISO();
  const rec = SRS[id] || {intervalIdx:0, due: now};
  rec.intervalIdx = Math.min(DFLT_INTERVALS.length-1, rec.intervalIdx+1);
  const days = DFLT_INTERVALS[rec.intervalIdx];
  const due = new Date(); due.setDate(due.getDate()+days);
  rec.due = due.toISOString().slice(0,10);
  SRS[id] = rec; saveState(); updateDueBadge();
}
function resetSRS(id){
  const now = todayISO();
  SRS[id] = {intervalIdx:0, due: now}; saveState(); updateDueBadge();
}
function updateDueBadge(){
  const today = todayISO();
  let due = 0;
  for(const id in SRS){ if(SRS[id].due <= today) due++; }
  document.getElementById('due').textContent = `Pendientes hoy: ${due}`;
}

/* ---------- Exportaci√≥n ---------- */
function exportDeck(){
  if(QUESTIONS.length===0){ alert('Nada que exportar.'); return; }
  const fmt = document.getElementById('exportFmt').value;
  let out = '';
  if(fmt==='csv'){
    out = 'tipo,pregunta,respuesta,frase\n';
    for(const q of QUESTIONS){
      const stem = q.stem || q.question || '';
      const ansText = Number.isInteger(q.correctIdx) && q.correctIdx>=0 ? q.choices[q.correctIdx] : (q.answer||'');
      out += `"${q.type}","${(stem).replace(/"/g,'""')}","${(ansText).replace(/"/g,'""')}","${(q.sent||'').replace(/"/g,'""')}"\n`;
    }
    download('quiz_export.csv', out);
  } else if(fmt==='anki'){
    for(const q of QUESTIONS){
      const stem = q.stem || q.question || '';
      const ansText = Number.isInteger(q.correctIdx) && q.correctIdx>=0 ? q.choices[q.correctIdx] : (q.answer||'');
      out += `${escapeTabs(stem)}\t${escapeTabs(ansText || q.sent || '')}\n`;
    }
    download('quiz_anki.tsv', out);
  } else {
    for(const q of QUESTIONS){
      const stem = q.stem || q.question || '';
      const ansText = Number.isInteger(q.correctIdx) && q.correctIdx>=0 ? q.choices[q.correctIdx] : (q.answer||'');
      out += `- **${stem}**\n  - ${ansText || q.sent || ''}\n\n`;
    }
    download('quiz_remnote.md', out);
  }
}
function escapeTabs(s){ return (s||'').replace(/\t/g,' ').replace(/\n/g,'<br>'); }
function download(filename, text){
  const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 500);
}

/* ---------- Control ---------- */
// --- Cloudflare Temas: listeners ---
document.getElementById('generateAI').addEventListener('click', generateAI);

document.getElementById('startQuiz').addEventListener('click', ()=>{
  CURRENT = 0; SCORE = 0; WRONG.clear();
  CORRECT = 0; INCORRECT = 0;
  const next = document.getElementById('nextQ'); if(next) next.disabled = false;
  updateUI();
});
document.getElementById('nextQ').addEventListener('click', nextQ);
document.getElementById('prevQ').addEventListener('click', prevQ);

document.getElementById('reviewWrong').addEventListener('click', async ()=>{
  const base = getWorkerBase();
  // Construye CSV de temas seleccionados (si hay)
  const topics = [...SELECCION].join(',');
  if (base){
    try{
      setStatus('Cargando fallos remotos‚Ä¶');
      const url = new URL(base + '/wrong');
      if (topics) url.searchParams.set('topics', topics);
      url.searchParams.set('limit','300');
      const res = await fetch(url.toString(), { method:'GET' });
      if(!res.ok) throw new Error('HTTP '+res.status);
      const data = await res.json();
      const items = Array.isArray(data.items) ? data.items : [];
      if (items.length === 0){
        alert('No hay fallos remotos (a√∫n).'); setStatus('Listo'); return;
      }
      // Transforma a tu formato QUESTIONS
      QUESTIONS = items.map((it, i) => ({
        id: it.id || ('wrong_'+(i+1)),
        type: 'mcq',
        topic: it.topic,
        stem: it.stem,
        sent: it.source_quote || '',
        answer: (Array.isArray(it.choices) && Number.isInteger(it.correctIdx) ? it.choices[it.correctIdx] : ''),
        choices: it.choices || [],
        explanation: it.explanation || '',
        answer_index: it.correctIdx,
        correctIdx: it.correctIdx,
        fromWrong: true
      }));
      CURRENT = 0; SCORE = 0; CORRECT = 0; INCORRECT = 0;
      updateUI(); setStatus(`Fallos: ${QUESTIONS.length}`);
      return;
    }catch(e){
      console.warn('Fallo leyendo remotos:', e);
      // caer al local
    }finally{
      saveState();
    }
  }
  // Fallback a fallos locales si no hay Worker o fall√≥ la lectura
  if(WRONG.size===0){ alert('No hay fallos acumulados.'); return; }
  const ids = new Set(WRONG);
  QUESTIONS = QUESTIONS.filter(q=>ids.has(q.id));
  CURRENT = 0; updateUI();
});

document.getElementById('exportDeck').addEventListener('click', exportDeck);

document.addEventListener('keydown', (e)=>{
  if(e.key>='1' && e.key<='5'){
    const n = parseInt(e.key,10);
    const area = document.querySelector('.choices');
    if(area){ const btn = area.children[n-1]; if(btn) btn.click(); }
  } else if(e.key==='n' || e.key==='N'){ nextQ(); }
});

// init
loadState(); updateUI();
</script>
</body>
</html>
